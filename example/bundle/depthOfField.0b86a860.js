function t(t,e,n,r){Object.defineProperty(t,e,{get:n,set:r,enumerable:!0,configurable:!0})}var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},n={},r={},a=e.parcelRequire5b70;null==a&&((a=function(t){if(t in n)return n[t].exports;if(t in r){var e=r[t];delete r[t];var a={id:t,exports:{}};return n[t]=a,e.call(a.exports,a,a.exports),a.exports}var i=new Error("Cannot find module '"+t+"'");throw i.code="MODULE_NOT_FOUND",i}).register=function(t,e){r[t]=e},e.parcelRequire5b70=a),a.register("4CEV9",(function(e,n){t(e.exports,"PathTracingRenderer",(()=>a("hWds8").PathTracingRenderer)),t(e.exports,"DynamicPathTracingSceneGenerator",(()=>a("lDKrr").DynamicPathTracingSceneGenerator)),t(e.exports,"MaterialReducer",(()=>a("62xhu").MaterialReducer)),t(e.exports,"PhysicalCamera",(()=>a("csrdQ").PhysicalCamera)),t(e.exports,"PhysicalPathTracingMaterial",(()=>a("9dwDm").PhysicalPathTracingMaterial)),a("hWds8"),a("lDKrr"),a("62xhu"),a("csrdQ"),a("9dwDm")})),a.register("hWds8",(function(e,n){t(e.exports,"PathTracingRenderer",(()=>l));var r=a("ilwiq"),i=a("RPVlj");function*o(){const{_fsQuad:t,_renderer:e,target:n,camera:r,material:a}=this;for(;;){a.opacity=1/(this.samples+1),a.seed++;const i=n.width,o=n.height;r.setViewOffset(i,o,Math.random()-.5,Math.random()-.5,i,o),r.updateProjectionMatrix();const s=this.tiles.x||1,l=this.tiles.y||1,c=s*l,u=1/e.getPixelRatio();for(let f=0;f<l;f++)for(let h=0;h<s;h++){a.cameraWorldMatrix.copy(r.matrixWorld),a.invProjectionMatrix.copy(r.projectionMatrixInverse);const m=e.getRenderTarget(),d=e.autoClear;e.setRenderTarget(n),e.setScissorTest(!0),e.setScissor(u*Math.ceil(h*i/s),u*Math.ceil((l-f-1)*o/l),u*Math.ceil(i/s),u*Math.ceil(o/l)),e.autoClear=!1,t.render(e),e.setScissorTest(!1),e.setRenderTarget(m),e.autoClear=d,this.samples+=1/c,yield}this.samples=Math.round(this.samples)}}const s=new r.Color;class l{get material(){return this._fsQuad.material}set material(t){this._fsQuad.material=t}constructor(t){this.camera=null,this.tiles=new r.Vector2(1,1),this.target=new r.WebGLRenderTarget(1,1,{format:r.RGBAFormat,type:r.FloatType}),this.samples=0,this.stableNoise=!1,this._renderer=t,this._fsQuad=new i.FullScreenQuad(null),this._task=null}setSize(t,e){this.target.setSize(t,e),this.reset()}reset(){const t=this._renderer,e=this.target,n=t.getRenderTarget(),r=t.getClearAlpha();t.getClearColor(s),t.setRenderTarget(e),t.setClearColor(0,0),t.clearColor(),t.setClearColor(s,r),t.setRenderTarget(n),this.samples=0,this._task=null,this.stableNoise&&(this.material.seed=0)}update(){this._task||(this._task=o.call(this)),this._task.next()}}})),a.register("lDKrr",(function(e,n){t(e.exports,"DynamicPathTracingSceneGenerator",(()=>s));var r=a("ilwiq"),i=a("8Zfx2"),o=a("jM3IF");class s{get initialized(){return Boolean(this.bvh)}constructor(t){this.scene=t,this.bvh=null,this.geometry=new r.BufferGeometry,this.materials=null,this.textures=null,this.staticGeometryGenerator=new i.StaticGeometryGenerator(t)}reset(){this.geometry.dispose(),this.geometry=new r.BufferGeometry,this.materials=null,this.textures=null,this.staticGeometryGenerator=new i.StaticGeometryGenerator(this.scene)}dispose(){}generate(){const{scene:t,staticGeometryGenerator:e,geometry:n}=this;if(null===this.bvh){const r=["position","normal","tangent","uv"];t.traverse((t=>{if(t.isMesh){const e=!!t.material.normalMap;o.setCommonAttributes(t.geometry,{attributes:r,normalMapRequired:e})}}));const a=new Set,s=e.getMaterials();s.forEach((t=>{for(const e in t){const n=t[e];n&&n.isTexture&&a.add(n)}})),e.attributes=r,e.generate(n);const l=o.getGroupMaterialIndicesAttribute(n,s,s);return n.setAttribute("materialIndex",l),n.clearGroups(),this.bvh=new i.MeshBVH(n),this.materials=s,this.textures=Array.from(a),{bvh:this.bvh,materials:this.materials,textures:this.textures,scene:t}}{const{bvh:r}=this;return e.generate(n),r.refit(),{bvh:this.bvh,materials:this.materials,textures:this.textures,scene:t}}}}})),a.register("62xhu",(function(e,n){function r(t){return t.buffer instanceof ArrayBuffer&&"BYTES_PER_ELEMENT"in t}t(e.exports,"MaterialReducer",(()=>a));class a{constructor(){const t=new Set;t.add("uuid"),this.ignoreKeys=t,this.shareTextures=!0,this.textures=[],this.materials=[]}areEqual(t,e){const n=new Set,a=new Set,i=this.ignoreKeys,o=(t,e)=>{if(t===e)return!0;if(t&&e&&t instanceof Object&&e instanceof Object){if(a.has(t)||a.has(e))throw new Error("MaterialReducer: Material is recursive.");const s=t instanceof Element,l=e instanceof Element;if(s||l)return s===l&&t instanceof Image&&e instanceof Image&&t.src===e.src;const c=t instanceof ImageBitmap,u=e instanceof ImageBitmap;if(c||u)return!1;if(t.equals)return t.equals(e);const f=r(t),h=r(e);if(f||h){if(f!==h||t.constructor!==e.constructor||t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}a.add(t),a.add(e),n.clear();for(const e in t)!t.hasOwnProperty(e)||t[e]instanceof Function||i.has(e)||n.add(e);for(const t in e)!e.hasOwnProperty(t)||e[t]instanceof Function||i.has(t)||n.add(t);const m=Array.from(n.values());let d=!0;for(const n in m){const r=m[n];if(!i.has(r)&&(d=o(t[r],e[r]),!d))break}return a.delete(t),a.delete(e),d}return!1};return o(t,e)}process(t){const{textures:e,materials:n}=this;let r=0;const a=t=>{let a=null;for(const e in n){const r=n[e];this.areEqual(t,r)&&(a=r)}if(a)return r++,a;if(n.push(t),this.shareTextures)for(const n in t){if(!t.hasOwnProperty(n))continue;const r=t[n];if(r&&r.isTexture&&r.image instanceof Image){let a=null;for(const t in e){const n=e[t];if(this.areEqual(n,r)){a=n;break}}a?t[n]=a:e.push(r)}}return t};return t.traverse((t=>{if(t.isMesh&&t.material){const e=t.material;if(Array.isArray(e))for(let t=0;t<e.length;t++)e[t]=a(e[t]);else t.material=a(e)}})),{replaced:r,retained:n.length}}}})),a.register("csrdQ",(function(e,n){t(e.exports,"PhysicalCamera",(()=>i));var r=a("ilwiq");class i extends r.PerspectiveCamera{set bokehSize(t){this.fStop=this.getFocalLength()/t}get bokehSize(){return this.getFocalLength()/this.fStop}constructor(...t){super(...t),this.fStop=1.4,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=25,this.anamorphicRatio=1}}})),a.register("9dwDm",(function(e,n){t(e.exports,"PhysicalPathTracingMaterial",(()=>m));var r=a("ilwiq"),i=a("9fZ6X"),o=a("8Zfx2"),s=a("5Wq6T"),l=a("dJ2FF"),c=a("12pjC"),u=a("fcAdp"),f=a("jNhCl"),h=a("iyhQ7");class m extends i.MaterialBase{get envMap(){return this.environmentMap}constructor(t){super({transparent:!0,depthWrite:!1,defines:{DOF_SUPPORT:1,TRANSPARENT_TRAVERSALS:5,MATERIAL_LENGTH:0,GRADIENT_BG:0},uniforms:{bounces:{value:3},physicalCamera:{value:new h.PhysicalCameraUniform},bvh:{value:new o.MeshBVHUniformStruct},normalAttribute:{value:new o.FloatVertexAttributeTexture},tangentAttribute:{value:new o.FloatVertexAttributeTexture},uvAttribute:{value:new o.FloatVertexAttributeTexture},materialIndexAttribute:{value:new o.UIntVertexAttributeTexture},materials:{value:new l.MaterialStructArrayUniform},textures:{value:(new c.RenderTarget2DArray).texture},cameraWorldMatrix:{value:new r.Matrix4},invProjectionMatrix:{value:new r.Matrix4},environmentBlur:{value:.2},environmentIntensity:{value:2},environmentMap:{value:null},environmentRotation:{value:new r.Matrix3},seed:{value:0},opacity:{value:1},filterGlossyFactor:{value:0},gradientTop:{value:new r.Color(12572927)},gradientBottom:{value:new r.Color(16777215)},bgGradientTop:{value:new r.Color(1118481)},bgGradientBottom:{value:new r.Color(0)}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\t\t\t\t#define RAY_OFFSET 1e-5\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${o.shaderStructs}\n\t\t\t\t${o.shaderIntersectFunction}\n\t\t\t\t${s.shaderMaterialStructs}\n\n\t\t\t\t${f.shaderUtils}\n\t\t\t\t${u.shaderMaterialSampling}\n\n\t\t\t\t#ifdef USE_ENVMAP\n\n\t\t\t\tuniform float environmentBlur;\n\t\t\t\tuniform sampler2D environmentMap;\n\t\t\t\tuniform mat3 environmentRotation;\n\n\t\t\t\t#else\n\n\t\t\t\tuniform vec3 gradientTop;\n\t\t\t\tuniform vec3 gradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if GRADIENT_BG\n\n\t\t\t\tuniform vec3 bgGradientTop;\n\t\t\t\tuniform vec3 bgGradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if DOF_SUPPORT\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\tuniform int bounces;\n\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\tuniform sampler2D normalAttribute;\n\t\t\t\tuniform sampler2D tangentAttribute;\n\t\t\t\tuniform sampler2D uvAttribute;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float environmentIntensity;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform Material materials[ MATERIAL_LENGTH ];\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\n\t\t\t\t\t// get [-1, 1] normalized device coordinates\n\t\t\t\t\tvec2 ndc = 2.0 * vUv - vec2( 1.0 );\n\t\t\t\t\tvec3 rayOrigin, rayDirection;\n\t\t\t\t\tndcToCameraRay( ndc, cameraWorldMatrix, invProjectionMatrix, rayOrigin, rayDirection );\n\n\t\t\t\t\t#if DOF_SUPPORT\n\n\t\t\t\t\t// depth of field\n\t\t\t\t\tvec3 focalPoint = rayOrigin + normalize( rayDirection ) * physicalCamera.focusDistance;\n\n\t\t\t\t\t// get the aperture sample\n\t\t\t\t\tvec2 apertureSample = sampleAperture( physicalCamera.apertureBlades ) * physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t\t\t// rotate the aperture shape\n\t\t\t\t\tfloat ac = cos( physicalCamera.apertureRotation );\n\t\t\t\t\tfloat as = sin( physicalCamera.apertureRotation );\n\t\t\t\t\tapertureSample = vec2(\n\t\t\t\t\t\tapertureSample.x * ac - apertureSample.y * as,\n\t\t\t\t\t\tapertureSample.x * as + apertureSample.y * ac\n\t\t\t\t\t);\n\t\t\t\t\tapertureSample.x *= saturate( physicalCamera.anamorphicRatio );\n\t\t\t\t\tapertureSample.y *= saturate( 1.0 / physicalCamera.anamorphicRatio );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// create the new ray\n\t\t\t\t\trayOrigin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\t\t\trayDirection = focalPoint - rayOrigin;\n\n\t\t\t\t\t// Lambertian render\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\tvec3 throughputColor = vec3( 1.0 );\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\t\t\t\t\tfloat accumulatedRoughness = 0.0;\n\t\t\t\t\tint i;\n\t\t\t\t\tint transparentTraversals = TRANSPARENT_TRAVERSALS;\n\t\t\t\t\tfor ( i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tif ( ! bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\n\n\t\t\t\t\t\t\t#if GRADIENT_BG\n\n\t\t\t\t\t\t\tif ( i == 0 ) {\n\n\t\t\t\t\t\t\t\trayDirection = normalize( rayDirection + randDirection() * 0.05 );\n\t\t\t\t\t\t\t\tfloat value = ( rayDirection.y + 1.0 ) / 2.0;\n\n\t\t\t\t\t\t\t\tvalue = pow( value, 2.0 );\n\n\t\t\t\t\t\t\t\tgl_FragColor = vec4( mix( bgGradientBottom, bgGradientTop, value ), 1.0 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t#ifdef USE_ENVMAP\n\n                            vec3 skyColor = textureCubeUV( environmentMap, environmentRotation * rayDirection, environmentBlur ).rgb;\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\t\t\t\t\t\t\tfloat value = ( rayDirection.y + 1.0 ) / 2.0;\n\t\t\t\t\t\t\tvec3 skyColor = mix( gradientBottom, gradientTop, value );\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tgl_FragColor += vec4( skyColor * throughputColor * environmentIntensity, 1.0 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = materials[ materialIndex ];\n\n\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\n\t\t\t\t\t\t// albedo\n\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uv, material.map ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t\t\t\t\t// and it's single sided.\n\t\t\t\t\t\t// - alpha test is disabled when it === 0\n\t\t\t\t\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t\t\t\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t\t\t\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\t\t\tbool isFirstHit = i == 0;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\t\tmaterial.side != 0.0 && ( side != material.side ) == isFirstHit\n\n\t\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t\t|| ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\trayOrigin += rayDirection * dist - faceNormal * RAY_OFFSET;\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( transparentTraversals );\n\t\t\t\t\t\t\ttransparentTraversals -= sign( transparentTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// fetch the interpolated smooth normal\n\t\t\t\t\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t).xyz );\n\n\t\t\t\t\t\t// roughness\n\t\t\t\t\t\tfloat roughness = material.roughness;\n\t\t\t\t\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\troughness *= texture2D( textures, vec3( uv, material.roughnessMap ) ).g;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// metalness\n\t\t\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uv, material.metalnessMap ) ).b;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// emission\n\t\t\t\t\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\t\t\t\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\t\t\t\t\temission *= texture2D( textures, vec3( uv, material.emissiveMap ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// transmission\n\t\t\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uv, material.transmissionMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\ttangentAttribute,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uv, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormal *= side;\n\n\t\t\t\t\t\tSurfaceRec surfaceRec;\n\t\t\t\t\t\tsurfaceRec.normal = normal;\n\t\t\t\t\t\tsurfaceRec.faceNormal = faceNormal;\n\t\t\t\t\t\tsurfaceRec.transmission = transmission;\n\t\t\t\t\t\tsurfaceRec.ior = material.ior;\n\t\t\t\t\t\tsurfaceRec.emission = emission;\n\t\t\t\t\t\tsurfaceRec.metalness = metalness;\n\t\t\t\t\t\tsurfaceRec.color = albedo.rgb;\n\t\t\t\t\t\tsurfaceRec.roughness = roughness;\n\n\t\t\t\t\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t\t\t\t\t// then we can just always assume this is a front face.\n\t\t\t\t\t\tsurfaceRec.frontFace = side == 1.0 || transmission == 0.0;\n\n\t\t\t\t\t\t// Compute the filtered roughness value to use during specular reflection computations. A minimum\n\t\t\t\t\t\t// value of 1e-6 is needed because the GGX functions do not work with a roughness value of 0 and\n\t\t\t\t\t\t// the accumulated roughness value is scaled by a user setting and a "magic value" of 5.0.\n\t\t\t\t\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t\t\t\t\t// sharp internal reflections\n\t\t\t\t\t\tsurfaceRec.filteredRoughness = clamp(\n\t\t\t\t\t\t\tmax( surfaceRec.roughness, accumulatedRoughness * filterGlossyFactor * 5.0 ),\n\t\t\t\t\t\t\t1e-3,\n\t\t\t\t\t\t\t1.0\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tmat3 normalBasis = getBasisFromNormal( surfaceRec.normal );\n\t\t\t\t\t\tmat3 invBasis = inverse( normalBasis );\n\n\t\t\t\t\t\tvec3 outgoing = - normalize( invBasis * rayDirection );\n\t\t\t\t\t\tSampleRec sampleRec = bsdfSample( outgoing, surfaceRec );\n\n\t\t\t\t\t\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t\t\t\t\t\t// maximum component-wise value of the current point to accommodate floating point\n\t\t\t\t\t\t// error as values increase.\n\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\trayDirection = normalize( normalBasis * sampleRec.direction );\n\n\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\tif ( ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( outgoing + sampleRec.direction );\n\t\t\t\t\t\t\taccumulatedRoughness += sin( acos( halfVector.z ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate color\n\t\t\t\t\t\tgl_FragColor.rgb += ( emission * throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( sampleRec.pdf <= 0.0 || ! isDirectionValid( rayDirection, normal, faceNormal) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthroughputColor *= sampleRec.color / sampleRec.pdf;\n\n\t\t\t\t\t\t// discard the sample if there are any NaNs\n\t\t\t\t\t\tif ( any( isnan( throughputColor ) ) || any( isinf( throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a = opacity;\n\n\t\t\t\t}\n\n\t\t\t`}),this.setValues(t)}}})),a.register("dJ2FF",(function(e,n){t(e.exports,"MaterialStructArrayUniform",(()=>i));var r=a("b5klx");class i extends Array{updateFrom(t,e){for(;this.length>t.length;)this.pop();for(;this.length<t.length;)this.push(new r.MaterialStructUniform);for(let n=0,r=this.length;n<r;n++)this[n].updateFrom(t[n],e)}}})),a.register("b5klx",(function(e,n){t(e.exports,"MaterialStructUniform",(()=>i));var r=a("ilwiq");class i{constructor(){this.init()}init(){this.color=new r.Color(16777215),this.map=-1,this.metalness=1,this.metalnessMap=-1,this.roughness=1,this.roughnessMap=-1,this.ior=1,this.transmission=0,this.transmissionMap=-1,this.emissive=new r.Color(0),this.emissiveIntensity=1,this.emissiveMap=-1,this.normalMap=-1,this.normalScale=new r.Vector2(1,1),this.opacity=1,this.alphaTest=0,this.side=0}updateFrom(t,e=[]){this.init(),"color"in t?this.color.copy(t.color):t.color.set(16777215),this.map=e.indexOf(t.map),this.metalness="metalness"in t?t.metalness:1,this.metalnessMap=e.indexOf(t.metalnessMap),this.roughness="roughness"in t?t.roughness:1,this.roughnessMap=e.indexOf(t.roughnessMap),this.ior="ior"in t?t.ior:1,this.transmission="transmission"in t?t.transmission:0,"transmissionMap"in t&&(this.transmissionMap=e.indexOf(t.transmissionMap)),"emissive"in t?this.emissive.copy(t.emissive):this.emissive.set(0),this.emissiveIntensity="emissiveIntensity"in t?t.emissiveIntensity:1,this.emissiveMap=e.indexOf(t.emissiveMap),this.normalMap=e.indexOf(t.normalMap),"normalScale"in t?this.normalScale.copy(t.normalScale):this.normalScale.set(1,1),this.opacity=t.opacity,this.alphaTest=t.alphaTest}setSide(t){switch(t){case r.DoubleSide:this.side=0;break;case r.FrontSide:this.side=1;break;case r.BackSide:this.side=-1}}}})),a.register("12pjC",(function(e,n){t(e.exports,"RenderTarget2DArray",(()=>s));var r=a("ilwiq"),i=a("RPVlj");const o=new r.Color;class s extends r.WebGLArrayRenderTarget{constructor(...t){super(...t);const e=this.texture;e.format=r.RGBAFormat,e.type=r.UnsignedByteType,e.minFilter=r.LinearFilter,e.magFilter=r.LinearFilter,e.wrapS=r.RepeatWrapping,e.wrapT=r.RepeatWrapping,e.setTextures=(...t)=>{this.setTextures(...t)};const n=new i.FullScreenQuad(new r.MeshBasicMaterial);this.fsQuad=n}setTextures(t,e,n,a){const i=t.getRenderTarget(),s=t.toneMapping,l=t.getClearAlpha();t.getClearColor(o);const c=a.length;this.setSize(e,n,c),t.setClearColor(0,0),t.toneMapping=r.NoToneMapping;const u=this.fsQuad;for(let e=0,n=c;e<n;e++){const n=a[e];u.material.map=n,u.material.transparent=!0,t.setRenderTarget(this,e),u.render(t)}u.material.map=null,t.setClearColor(o,l),t.setRenderTarget(i),t.toneMapping=s}dispose(){super.dispose(),this.fsQuad.dispose()}}})),a.register("fcAdp",(function(e,n){t(e.exports,"shaderMaterialSampling",(()=>r));const r=`\n\nstruct SurfaceRec {\n\tvec3 normal;\n\tvec3 faceNormal;\n\tbool frontFace;\n\tfloat roughness;\n\tfloat filteredRoughness;\n\tfloat metalness;\n\tvec3 color;\n\tvec3 emission;\n\tfloat transmission;\n\tfloat ior;\n};\n\nstruct SampleRec {\n\tfloat pdf;\n\tvec3 direction;\n\tvec3 color;\n};\n\n${a("bmrjs").shaderGGXFunctions}\n\n// diffuse\nfloat diffusePDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#lightscattering/thescatteringpdf\n\tfloat cosValue = wi.z;\n\treturn cosValue / PI;\n\n}\n\nvec3 diffuseDirection( vec3 wo, SurfaceRec surf ) {\n\n\tvec3 lightDirection = randDirection();\n\tlightDirection.z += 1.0;\n\tlightDirection = normalize( lightDirection );\n\n\treturn lightDirection;\n\n}\n\nvec3 diffuseColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// TODO: scale by 1 - F here\n\t// note on division by PI\n\t// https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n\tfloat metalFactor = ( 1.0 - surf.metalness ) * wi.z / ( PI * PI );\n\tfloat transmissionFactor = 1.0 - surf.transmission;\n\treturn surf.color * metalFactor * transmissionFactor;\n\n}\n\n// specular\nfloat specularPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// See equation (17) in http://jcgt.org/published/0003/02/03/\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = getHalfVector( wi, wo );\n\treturn ggxPDF( wi, halfVector, filteredRoughness ) / ( 4.0 * dot( wi, halfVector ) );\n\n}\n\nvec3 specularDirection( vec3 wo, SurfaceRec surf ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = ggxDirection(\n\t\two,\n\t\tfilteredRoughness,\n\t\tfilteredRoughness,\n\t\trand(),\n\t\trand()\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\treturn - reflect( wo, halfVector );\n\n}\n\nvec3 specularColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// if roughness is set to 0 then D === NaN which results in black pixels\n\tfloat metalness = surf.metalness;\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\tfloat filteredRoughness = surf.filteredRoughness;\n\n\tvec3 halfVector = getHalfVector( wo, wi );\n\tfloat iorRatio = frontFace ? 1.0 / ior : ior;\n\tfloat G = ggxShadowMaskG2( wi, wo, filteredRoughness );\n\tfloat D = ggxDistribution( halfVector, filteredRoughness );\n\n\tfloat F = schlickFresnelFromIor( dot( wi, halfVector ), iorRatio );\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tbool cannotRefract = iorRatio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = 1.0;\n\n\t}\n\n\tvec3 color = mix( vec3( 1.0 ), surf.color, metalness );\n\tcolor = mix( color, vec3( 1.0 ), F );\n\tcolor *= G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\tcolor *= mix( F, 1.0, metalness );\n\tcolor *= wi.z; // scale the light by the direction the light is coming in from\n\n\treturn color;\n\n}\n\n/*\n// transmission\nfunction transmissionPDF( wo, wi, material, surf ) {\n\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? ior : 1 / ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\thalfVector.set( 0, 0, 0 ).addScaledVector( wi, ratio ).addScaledVector( wo, 1.0 ).normalize().multiplyScalar( - 1 );\n\n\tconst denom = Math.pow( ratio * halfVector.dot( wi ) + 1.0 * halfVector.dot( wo ), 2.0 );\n\treturn ggxPDF( wo, halfVector, minRoughness ) / denom;\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\t// sample ggx vndf distribution which gives a new normal\n\tggxDirection(\n\t\two,\n\t\tminRoughness,\n\t\tminRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, halfVector, ratio, lightDirection );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wo.z )\n\t\t.multiplyScalar( transmission );\n\n}\n*/\n\n// TODO: This is just using a basic cosine-weighted specular distribution with an\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\nfloat transmissionPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 1.0 - reflectance );\n\n}\n\nvec3 transmissionDirection( vec3 wo, SurfaceRec surf ) {\n\n\tfloat roughness = surf.roughness;\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\n\tvec3 lightDirection = refract( - wo, vec3( 0.0, 0.0, 1.0 ), ratio );\n\tlightDirection += randDirection() * roughness;\n\treturn normalize( lightDirection );\n\n}\n\nvec3 transmissionColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\n\tvec3 color = surf.color;\n\tcolor *= ( 1.0 - metalness );\n\tcolor *= transmission;\n\n\treturn color;\n\n}\n\nfloat bsdfPdf( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat ior = surf.ior;\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tfloat spdf = 0.0;\n\tfloat dpdf = 0.0;\n\tfloat tpdf = 0.0;\n\n\tif ( wi.z < 0.0 ) {\n\n\t\ttpdf = transmissionPDF( wo, wi, surf );\n\n\t} else {\n\n\t\tspdf = specularPDF( wo, wi, surf );\n\t\tdpdf = diffusePDF( wo, wi, surf );\n\n\t}\n\n\tfloat transSpecularProb = mix( reflectance, 1.0, metalness );\n\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\tfloat pdf =\n\t\tspdf * transmission * transSpecularProb\n\t\t+ tpdf * transmission * ( 1.0 - transSpecularProb )\n\t\t+ spdf * ( 1.0 - transmission ) * diffSpecularProb\n\t\t+ dpdf * ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\n\treturn pdf;\n\n}\n\nvec3 bsdfColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tvec3 color = vec3( 0.0 );\n\tif ( wi.z < 0.0 ) {\n\n\t\tcolor = transmissionColor( wo, wi, surf );\n\n\t} else {\n\n\t\tcolor = diffuseColor( wo, wi, surf );\n\t\tcolor *= 1.0 - surf.transmission;\n\n\t\tcolor += specularColor( wo, wi, surf );\n\n\t}\n\n\treturn color;\n\n}\n\nSampleRec bsdfSample( vec3 wo, SurfaceRec surf ) {\n\n\tfloat ior = surf.ior;\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tSampleRec result;\n\tif ( rand() < transmission ) {\n\n\t\tfloat specularProb = mix( reflectance, 1.0, metalness );\n\t\tif ( rand() < specularProb ) {\n\n\t\t\tresult.direction = specularDirection( wo, surf );\n\n\t\t} else {\n\n\t\t\tresult.direction = transmissionDirection( wo, surf );\n\n\t\t}\n\n\t} else {\n\n\t\tfloat specularProb = 0.5 + 0.5 * metalness;\n\t\tif ( rand() < specularProb ) {\n\n\t\t\tresult.direction = specularDirection( wo, surf );\n\n\t\t} else {\n\n\t\t\tresult.direction = diffuseDirection( wo, surf );\n\n\t\t}\n\n\t}\n\n\tresult.pdf = bsdfPdf( wo, result.direction, surf );\n\tresult.color = bsdfColor( wo, result.direction, surf );\n\treturn result;\n\n}\n`})),a.register("bmrjs",(function(e,n){t(e.exports,"shaderGGXFunctions",(()=>r));const r="\n// The GGX functions provide sampling and distribution information for normals as output so\n// in order to get probability of scatter direction the half vector must be computed and provided.\n// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n// [2] http://jcgt.org/published/0007/04/01/\n// [4] http://jcgt.org/published/0003/02/03/\n\n// trowbridge-reitz === GGX === GTR\n\nvec3 ggxDirection( vec3 incidentDir, float roughnessX, float roughnessY, float random1, float random2 ) {\n\n\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t// function below, as well\n\n\t// Implementation from reference [1]\n\t// stretch view\n\tvec3 V = normalize( vec3( roughnessX * incidentDir.x, roughnessY * incidentDir.y, incidentDir.z ) );\n\n\t// orthonormal basis\n\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\tvec3 T2 = cross( T1, V );\n\n\t// sample point with polar coordinates (r, phi)\n\tfloat a = 1.0 / ( 1.0 + V.z );\n\tfloat r = sqrt( random1 );\n\tfloat phi = ( random2 < a ) ? random2 / a * PI : PI + ( random2 - a ) / ( 1.0 - a ) * PI;\n\tfloat P1 = r * cos( phi );\n\tfloat P2 = r * sin( phi ) * ( ( random2 < a ) ? 1.0 : V.z );\n\n\t// compute normal\n\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t// unstretch\n\tN = normalize( vec3( roughnessX * N.x, roughnessY * N.y, max( 0.0, N.z ) ) );\n\n\treturn N;\n\n}\n\n// Below are PDF and related functions for use in a Monte Carlo path tracer\n// as specified in Appendix B of the following paper\n// See equation (2) from reference [2]\nfloat ggxLamda( float theta, float roughness ) {\n\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = tanTheta * tanTheta;\n\tfloat alpha2 = roughness * roughness;\n\n\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\treturn numerator / 2.0;\n\n}\n\n// See equation (2) from reference [2]\nfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n}\n\n// See equation (125) from reference [4]\nfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat scatterTheta = acos( wo.z );\n\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n}\n\nfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t// See equation (33) from reference [0]\n\tfloat a2 = roughness * roughness;\n\tfloat cosTheta = halfVector.z;\n\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\tif ( cosTheta == 0.0 ) return 0.0;\n\n\tfloat theta = acos( halfVector.z );\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\treturn a2 / denom;\n\n\t// See equation (1) from reference [2]\n\t// const { x, y, z } = halfVector;\n\t// const a2 = roughness * roughness;\n\t// const mult = x * x / a2 + y * y / a2 + z * z;\n\t// const mult2 = mult * mult;\n\n\t// return 1.0 / Math.PI * a2 * mult2;\n\n}\n\n// See equation (3) from reference [2]\nfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat D = ggxDistribution( halfVector, roughness );\n\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n}\n"})),a.register("iyhQ7",(function(e,n){t(e.exports,"PhysicalCameraUniform",(()=>i));var r=a("csrdQ");class i{constructor(){this.bokehSize=0,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=10,this.anamorphicRatio=1}updateFrom(t){t instanceof r.PhysicalCamera?(this.bokehSize=t.bokehSize,this.apertureBlades=t.apertureBlades,this.apertureRotation=t.apertureRotation,this.focusDistance=t.focusDistance,this.anamorphicRatio=t.anamorphicRatio):(this.bokehSize=0,this.apertureRotation=0,this.apertureBlades=0,this.focusDistance=10,this.anamorphicRatio=1)}}})),a.register("891vQ",(function(e,n){t(e.exports,"RGBELoader",(()=>i));var r=a("ilwiq");class i extends r.DataTextureLoader{constructor(t){super(t),this.type=r.HalfFloatType}parse(t){const e=function(t,e){switch(t){case 1:console.error("THREE.RGBELoader Read Error: "+(e||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(e||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(e||""));break;default:console.error("THREE.RGBELoader: Error: "+(e||""))}return-1},n=function(t,e,n){e=e||1024;let r=t.pos,a=-1,i=0,o="",s=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));for(;0>(a=s.indexOf("\n"))&&i<e&&r<t.byteLength;)o+=s,i+=s.length,r+=128,s+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));return-1<a&&(!1!==n&&(t.pos+=i+a+1),o+s.slice(0,a))},a=function(t,e,n,r){const a=t[e+3],i=Math.pow(2,a-128)/255;n[r+0]=t[e+0]*i,n[r+1]=t[e+1]*i,n[r+2]=t[e+2]*i,n[r+3]=1},i=function(t,e,n,a){const i=t[e+3],o=Math.pow(2,i-128)/255;n[a+0]=r.DataUtils.toHalfFloat(Math.min(t[e+0]*o,65504)),n[a+1]=r.DataUtils.toHalfFloat(Math.min(t[e+1]*o,65504)),n[a+2]=r.DataUtils.toHalfFloat(Math.min(t[e+2]*o,65504)),n[a+3]=r.DataUtils.toHalfFloat(1)},o=new Uint8Array(t);o.pos=0;const s=function(t){const r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*FORMAT=(\S+)\s*$/,o=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,s={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;if(t.pos>=t.byteLength||!(l=n(t)))return e(1,"no header found");if(!(c=l.match(/^#\?(\S+)/)))return e(3,"bad initial token");for(s.valid|=1,s.programtype=c[1],s.string+=l+"\n";l=n(t),!1!==l;)if(s.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(r))&&(s.gamma=parseFloat(c[1])),(c=l.match(a))&&(s.exposure=parseFloat(c[1])),(c=l.match(i))&&(s.valid|=2,s.format=c[1]),(c=l.match(o))&&(s.valid|=4,s.height=parseInt(c[1],10),s.width=parseInt(c[2],10)),2&s.valid&&4&s.valid)break}else s.comments+=l+"\n";return 2&s.valid?4&s.valid?s:e(3,"missing image size specifier"):e(3,"missing format specifier")}(o);if(-1!==s){const t=s.width,n=s.height,l=function(t,n,r){const a=n;if(a<8||a>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(a!==(t[2]<<8|t[3]))return e(3,"wrong scanline width");const i=new Uint8Array(4*n*r);if(!i.length)return e(4,"unable to allocate buffer space");let o=0,s=0;const l=4*a,c=new Uint8Array(4),u=new Uint8Array(l);let f=r;for(;f>0&&s<t.byteLength;){if(s+4>t.byteLength)return e(1);if(c[0]=t[s++],c[1]=t[s++],c[2]=t[s++],c[3]=t[s++],2!=c[0]||2!=c[1]||(c[2]<<8|c[3])!=a)return e(3,"bad rgbe scanline format");let n,r=0;for(;r<l&&s<t.byteLength;){n=t[s++];const a=n>128;if(a&&(n-=128),0===n||r+n>l)return e(3,"bad scanline data");if(a){const e=t[s++];for(let t=0;t<n;t++)u[r++]=e}else u.set(t.subarray(s,s+n),r),r+=n,s+=n}const h=a;for(let t=0;t<h;t++){let e=0;i[o]=u[t+e],e+=a,i[o+1]=u[t+e],e+=a,i[o+2]=u[t+e],e+=a,i[o+3]=u[t+e],o+=4}f--}return i}(o.subarray(o.pos),t,n);if(-1!==l){let e,o,c,u;switch(this.type){case r.FloatType:u=l.length/4;const t=new Float32Array(4*u);for(let e=0;e<u;e++)a(l,4*e,t,4*e);e=t,c=r.FloatType;break;case r.HalfFloatType:u=l.length/4;const n=new Uint16Array(4*u);for(let t=0;t<u;t++)i(l,4*t,n,4*t);e=n,c=r.HalfFloatType;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:t,height:n,data:e,header:s.string,gamma:s.gamma,exposure:s.exposure,format:o,type:c}}}return null}setDataType(t){return this.type=t,this}load(t,e,n,a){return super.load(t,(function(t,n){switch(t.type){case r.FloatType:case r.HalfFloatType:t.encoding=r.LinearEncoding,t.minFilter=r.LinearFilter,t.magFilter=r.LinearFilter,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,n)}),n,a)}}}));
//# sourceMappingURL=depthOfField.0b86a860.js.map
