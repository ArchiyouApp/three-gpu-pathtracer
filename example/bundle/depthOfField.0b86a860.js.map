{"mappings":"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","sources":["src/index.js","src/core/PathTracingRenderer.js","src/core/DynamicPathTracingSceneGenerator.js","src/core/MaterialReducer.js","src/core/PhysicalCamera.js","src/materials/PhysicalPathTracingMaterial.js","src/uniforms/MaterialStructArrayUniform.js","src/uniforms/MaterialStructUniform.js","src/uniforms/RenderTarget2DArray.js","src/shader/shaderMaterialSampling.js","src/shader/shaderGGXFunctions.js","src/uniforms/PhysicalCameraUniform.js","node_modules/three/examples/jsm/loaders/RGBELoader.js"],"sourcesContent":["// core\nexport * from './core/PathTracingRenderer.js';\nexport * from './core/PathTracingSceneGenerator.js';\nexport * from './core/DynamicPathTracingSceneGenerator.js';\nexport * from './core/MaterialReducer.js';\nexport * from './core/PhysicalCamera.js';\n\n// uniforms\nexport * from './uniforms/MaterialStructArrayUniform.js';\nexport * from './uniforms/MaterialStructUniform.js';\nexport * from './uniforms/RenderTarget2DArray.js';\n\n// utils\nexport * from './utils/GeometryPreparationUtils.js';\n\n// materials\nexport * from './materials/MaterialBase.js';\nexport * from './materials/PhysicalPathTracingMaterial.js';\n\n// shaders\nexport * from './shader/shaderMaterialSampling.js';\nexport * from './shader/shaderUtils.js';\nexport * from './shader/shaderStructs.js';\n","import { RGBAFormat, FloatType, Color, Vector2, WebGLRenderTarget } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\n\nfunction* renderTask() {\n\n\tconst { _fsQuad, _renderer, target, camera, material } = this;\n\twhile ( true ) {\n\n\t\tmaterial.opacity = 1 / ( this.samples + 1 );\n\t\tmaterial.seed ++;\n\n\t\tconst w = target.width;\n\t\tconst h = target.height;\n\t\tcamera.setViewOffset(\n\t\t\tw, h,\n\t\t\tMath.random() - 0.5, Math.random() - 0.5,\n\t\t\tw, h,\n\t\t);\n\t\tcamera.updateProjectionMatrix();\n\n\t\tconst tx = this.tiles.x || 1;\n\t\tconst ty = this.tiles.y || 1;\n\t\tconst totalTiles = tx * ty;\n\t\tconst dprInv = ( 1 / _renderer.getPixelRatio() );\n\t\tfor ( let y = 0; y < ty; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < tx; x ++ ) {\n\n\t\t\t\tmaterial.cameraWorldMatrix.copy( camera.matrixWorld );\n\t\t\t\tmaterial.invProjectionMatrix.copy( camera.projectionMatrixInverse );\n\n\t\t\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\t\t\tconst ogAutoClear = _renderer.autoClear;\n\n\t\t\t\t// three.js renderer takes values relative to the current pixel ratio\n\t\t\t\t_renderer.setRenderTarget( target );\n\t\t\t\t_renderer.setScissorTest( true );\n\t\t\t\t_renderer.setScissor(\n\t\t\t\t\tdprInv * Math.ceil( x * w / tx ),\n\t\t\t\t\tdprInv * Math.ceil( ( ty - y - 1 ) * h / ty ),\n\t\t\t\t\tdprInv * Math.ceil( w / tx ),\n\t\t\t\t\tdprInv * Math.ceil( h / ty ) );\n\t\t\t\t_renderer.autoClear = false;\n\t\t\t\t_fsQuad.render( _renderer );\n\n\t\t\t\t_renderer.setScissorTest( false );\n\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\t\t\t\t_renderer.autoClear = ogAutoClear;\n\n\t\t\t\tthis.samples += ( 1 / totalTiles );\n\n\t\t\t\tyield;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.samples = Math.round( this.samples );\n\n\t}\n\n}\n\nconst ogClearColor = new Color();\nexport class PathTracingRenderer {\n\n\tget material() {\n\n\t\treturn this._fsQuad.material;\n\n\t}\n\n\tset material( v ) {\n\n\t\tthis._fsQuad.material = v;\n\n\t}\n\n\tconstructor( renderer ) {\n\n\t\tthis.camera = null;\n\t\tthis.tiles = new Vector2( 1, 1 );\n\t\tthis.target = new WebGLRenderTarget( 1, 1, {\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: FloatType,\n\t\t} );\n\t\tthis.samples = 0;\n\t\tthis.stableNoise = false;\n\t\tthis._renderer = renderer;\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\t\tthis._task = null;\n\n\t}\n\n\tsetSize( w, h ) {\n\n\t\tthis.target.setSize( w, h );\n\t\tthis.reset();\n\n\t}\n\n\treset() {\n\n\t\tconst renderer = this._renderer;\n\t\tconst target = this.target;\n\t\tconst ogRenderTarget = renderer.getRenderTarget();\n\t\tconst ogClearAlpha = renderer.getClearAlpha();\n\t\trenderer.getClearColor( ogClearColor );\n\n\t\trenderer.setRenderTarget( target );\n\t\trenderer.setClearColor( 0, 0 );\n\t\trenderer.clearColor();\n\n\t\trenderer.setClearColor( ogClearColor, ogClearAlpha );\n\t\trenderer.setRenderTarget( ogRenderTarget );\n\n\t\tthis.samples = 0;\n\t\tthis._task = null;\n\n\t\tif ( this.stableNoise ) {\n\n\t\t\tthis.material.seed = 0;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tif ( ! this._task ) {\n\n\t\t\tthis._task = renderTask.call( this );\n\n\t\t}\n\n\t\tthis._task.next();\n\n\t}\n\n}\n","import { BufferGeometry } from 'three';\nimport { StaticGeometryGenerator, MeshBVH } from 'three-mesh-bvh';\nimport { setCommonAttributes, getGroupMaterialIndicesAttribute } from '../utils/GeometryPreparationUtils.js';\n\nexport class DynamicPathTracingSceneGenerator {\n\n\tget initialized() {\n\n\t\treturn Boolean( this.bvh );\n\n\t}\n\n\tconstructor( scene ) {\n\n\t\tthis.scene = scene;\n\t\tthis.bvh = null;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.materials = null;\n\t\tthis.textures = null;\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( scene );\n\n\t}\n\n\treset() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.materials = null;\n\t\tthis.textures = null;\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( this.scene );\n\n\t}\n\n\tdispose() {}\n\n\tgenerate() {\n\n\t\tconst { scene, staticGeometryGenerator, geometry } = this;\n\t\tif ( this.bvh === null ) {\n\n\t\t\tconst attributes = [ 'position', 'normal', 'tangent', 'uv' ];\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tconst normalMapRequired = ! ! c.material.normalMap;\n\t\t\t\t\tsetCommonAttributes( c.geometry, { attributes, normalMapRequired } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst textureSet = new Set();\n\t\t\tconst materials = staticGeometryGenerator.getMaterials();\n\t\t\tmaterials.forEach( material => {\n\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\ttextureSet.add( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tstaticGeometryGenerator.attributes = attributes;\n\t\t\tstaticGeometryGenerator.generate( geometry );\n\n\t\t\tconst materialIndexAttribute = getGroupMaterialIndicesAttribute( geometry, materials, materials );\n\t\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\n\t\t\tgeometry.clearGroups();\n\n\t\t\tthis.bvh = new MeshBVH( geometry );\n\t\t\tthis.materials = materials;\n\t\t\tthis.textures = Array.from( textureSet );\n\n\t\t\treturn {\n\t\t\t\tbvh: this.bvh,\n\t\t\t\tmaterials: this.materials,\n\t\t\t\ttextures: this.textures,\n\t\t\t\tscene,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst { bvh } = this;\n\t\t\tstaticGeometryGenerator.generate( geometry );\n\t\t\tbvh.refit();\n\t\t\treturn {\n\t\t\t\tbvh: this.bvh,\n\t\t\t\tmaterials: this.materials,\n\t\t\t\ttextures: this.textures,\n\t\t\t\tscene,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\n}\n","// https://github.com/gkjohnson/webxr-sandbox/blob/main/skinned-mesh-batching/src/MaterialReducer.js\n\nfunction isTypedArray( arr ) {\n\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\n\n}\n\nexport class MaterialReducer {\n\n\tconstructor() {\n\n\t\tconst ignoreKeys = new Set();\n\t\tignoreKeys.add( 'uuid' );\n\n\t\tthis.ignoreKeys = ignoreKeys;\n\t\tthis.shareTextures = true;\n\t\tthis.textures = [];\n\t\tthis.materials = [];\n\n\t}\n\n\tareEqual( objectA, objectB ) {\n\n\t\tconst keySet = new Set();\n\t\tconst traverseSet = new Set();\n\t\tconst ignoreKeys = this.ignoreKeys;\n\n\t\tconst traverse = ( a, b ) => {\n\n\t\t\tif ( a === b ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\n\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\n\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsElement = a instanceof Element;\n\t\t\t\tconst bIsElement = b instanceof Element;\n\t\t\t\tif ( aIsElement || bIsElement ) {\n\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn a.src === b.src;\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsImageBitmap = a instanceof ImageBitmap;\n\t\t\t\tconst bIsImageBitmap = b instanceof ImageBitmap;\n\t\t\t\tif ( aIsImageBitmap || bIsImageBitmap ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( a.equals ) {\n\n\t\t\t\t\treturn a.equals( b );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\n\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.add( a );\n\t\t\t\ttraverseSet.add( b );\n\n\t\t\t\tkeySet.clear();\n\t\t\t\tfor ( const key in a ) {\n\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const key in b ) {\n\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tconst keys = Array.from( keySet.values() );\n\t\t\t\tlet result = true;\n\t\t\t\tfor ( const i in keys ) {\n\n\t\t\t\t\tconst key = keys[ i ];\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.delete( a );\n\t\t\t\ttraverseSet.delete( b );\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\treturn traverse( objectA, objectB );\n\n\t}\n\n\tprocess( object ) {\n\n\t\tconst { textures, materials } = this;\n\t\tlet replaced = 0;\n\n\t\tconst processMaterial = material => {\n\n\t\t\t// Check if another material matches this one\n\t\t\tlet foundMaterial = null;\n\t\t\tfor ( const i in materials ) {\n\n\t\t\t\tconst otherMaterial = materials[ i ];\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\n\n\t\t\t\t\tfoundMaterial = otherMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( foundMaterial ) {\n\n\t\t\t\treplaced ++;\n\t\t\t\treturn foundMaterial;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tif ( this.shareTextures ) {\n\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\n\n\t\t\t\t\t\t\tlet foundTexture = null;\n\t\t\t\t\t\t\tfor ( const i in textures ) {\n\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\n\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( foundTexture ) {\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t};\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = processMaterial( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn { replaced, retained: materials.length };\n\n\t}\n\n}\n","import { PerspectiveCamera } from 'three';\n\nexport class PhysicalCamera extends PerspectiveCamera {\n\n\tset bokehSize( size ) {\n\n\t\tthis.fStop = this.getFocalLength() / size;\n\n\t}\n\n\tget bokehSize() {\n\n\t\treturn this.getFocalLength() / this.fStop;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.fStop = 1.4;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 25;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n}\n","import { Matrix4, Matrix3, Color } from 'three';\nimport { MaterialBase } from './MaterialBase.js';\nimport {\n\tMeshBVHUniformStruct, FloatVertexAttributeTexture, UIntVertexAttributeTexture,\n\tshaderStructs, shaderIntersectFunction,\n} from 'three-mesh-bvh';\nimport { shaderMaterialStructs } from '../shader/shaderStructs.js';\nimport { MaterialStructArrayUniform } from '../uniforms/MaterialStructArrayUniform.js';\nimport { RenderTarget2DArray } from '../uniforms/RenderTarget2DArray.js';\nimport { shaderMaterialSampling } from '../shader/shaderMaterialSampling.js';\nimport { shaderUtils } from '../shader/shaderUtils.js';\nimport { PhysicalCameraUniform } from '../uniforms/PhysicalCameraUniform.js';\n\nexport class PhysicalPathTracingMaterial extends MaterialBase {\n\n\t// three.js relies on this field to add env map functions and defines\n\tget envMap() {\n\n\t\treturn this.environmentMap;\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false,\n\n\t\t\tdefines: {\n\t\t\t\tDOF_SUPPORT: 1,\n\t\t\t\tTRANSPARENT_TRAVERSALS: 5,\n\t\t\t\tMATERIAL_LENGTH: 0,\n\t\t\t\tGRADIENT_BG: 0,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\tbounces: { value: 3 },\n\t\t\t\tphysicalCamera: { value: new PhysicalCameraUniform() },\n\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\n\t\t\t\tnormalAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\ttangentAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\tuvAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\n\t\t\t\tmaterials: { value: new MaterialStructArrayUniform() },\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\n\t\t\t\tenvironmentBlur: { value: 0.2 },\n\t\t\t\tenvironmentIntensity: { value: 2.0 },\n\t\t\t\tenvironmentMap: { value: null },\n\t\t\t\tenvironmentRotation: { value: new Matrix3() },\n\t\t\t\tseed: { value: 0 },\n\t\t\t\topacity: { value: 1 },\n\t\t\t\tfilterGlossyFactor: { value: 0.0 },\n\n\t\t\t\tgradientTop: { value: new Color( 0xbfd8ff ) },\n\t\t\t\tgradientBottom: { value: new Color( 0xffffff ) },\n\n\t\t\t\tbgGradientTop: { value: new Color( 0x111111 ) },\n\t\t\t\tbgGradientBottom: { value: new Color( 0x000000 ) },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t#define RAY_OFFSET 1e-5\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${ shaderStructs }\n\t\t\t\t${ shaderIntersectFunction }\n\t\t\t\t${ shaderMaterialStructs }\n\n\t\t\t\t${ shaderUtils }\n\t\t\t\t${ shaderMaterialSampling }\n\n\t\t\t\t#ifdef USE_ENVMAP\n\n\t\t\t\tuniform float environmentBlur;\n\t\t\t\tuniform sampler2D environmentMap;\n\t\t\t\tuniform mat3 environmentRotation;\n\n\t\t\t\t#else\n\n\t\t\t\tuniform vec3 gradientTop;\n\t\t\t\tuniform vec3 gradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if GRADIENT_BG\n\n\t\t\t\tuniform vec3 bgGradientTop;\n\t\t\t\tuniform vec3 bgGradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if DOF_SUPPORT\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\tuniform int bounces;\n\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\tuniform sampler2D normalAttribute;\n\t\t\t\tuniform sampler2D tangentAttribute;\n\t\t\t\tuniform sampler2D uvAttribute;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float environmentIntensity;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform Material materials[ MATERIAL_LENGTH ];\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\n\t\t\t\t\t// get [-1, 1] normalized device coordinates\n\t\t\t\t\tvec2 ndc = 2.0 * vUv - vec2( 1.0 );\n\t\t\t\t\tvec3 rayOrigin, rayDirection;\n\t\t\t\t\tndcToCameraRay( ndc, cameraWorldMatrix, invProjectionMatrix, rayOrigin, rayDirection );\n\n\t\t\t\t\t#if DOF_SUPPORT\n\n\t\t\t\t\t// depth of field\n\t\t\t\t\tvec3 focalPoint = rayOrigin + normalize( rayDirection ) * physicalCamera.focusDistance;\n\n\t\t\t\t\t// get the aperture sample\n\t\t\t\t\tvec2 apertureSample = sampleAperture( physicalCamera.apertureBlades ) * physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t\t\t// rotate the aperture shape\n\t\t\t\t\tfloat ac = cos( physicalCamera.apertureRotation );\n\t\t\t\t\tfloat as = sin( physicalCamera.apertureRotation );\n\t\t\t\t\tapertureSample = vec2(\n\t\t\t\t\t\tapertureSample.x * ac - apertureSample.y * as,\n\t\t\t\t\t\tapertureSample.x * as + apertureSample.y * ac\n\t\t\t\t\t);\n\t\t\t\t\tapertureSample.x *= saturate( physicalCamera.anamorphicRatio );\n\t\t\t\t\tapertureSample.y *= saturate( 1.0 / physicalCamera.anamorphicRatio );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// create the new ray\n\t\t\t\t\trayOrigin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\t\t\trayDirection = focalPoint - rayOrigin;\n\n\t\t\t\t\t// Lambertian render\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\tvec3 throughputColor = vec3( 1.0 );\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\t\t\t\t\tfloat accumulatedRoughness = 0.0;\n\t\t\t\t\tint i;\n\t\t\t\t\tint transparentTraversals = TRANSPARENT_TRAVERSALS;\n\t\t\t\t\tfor ( i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tif ( ! bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\n\n\t\t\t\t\t\t\t#if GRADIENT_BG\n\n\t\t\t\t\t\t\tif ( i == 0 ) {\n\n\t\t\t\t\t\t\t\trayDirection = normalize( rayDirection + randDirection() * 0.05 );\n\t\t\t\t\t\t\t\tfloat value = ( rayDirection.y + 1.0 ) / 2.0;\n\n\t\t\t\t\t\t\t\tvalue = pow( value, 2.0 );\n\n\t\t\t\t\t\t\t\tgl_FragColor = vec4( mix( bgGradientBottom, bgGradientTop, value ), 1.0 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t#ifdef USE_ENVMAP\n\n                            vec3 skyColor = textureCubeUV( environmentMap, environmentRotation * rayDirection, environmentBlur ).rgb;\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\t\t\t\t\t\t\tfloat value = ( rayDirection.y + 1.0 ) / 2.0;\n\t\t\t\t\t\t\tvec3 skyColor = mix( gradientBottom, gradientTop, value );\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tgl_FragColor += vec4( skyColor * throughputColor * environmentIntensity, 1.0 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = materials[ materialIndex ];\n\n\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\n\t\t\t\t\t\t// albedo\n\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uv, material.map ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t\t\t\t\t// and it's single sided.\n\t\t\t\t\t\t// - alpha test is disabled when it === 0\n\t\t\t\t\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t\t\t\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t\t\t\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\t\t\tbool isFirstHit = i == 0;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\t\tmaterial.side != 0.0 && ( side != material.side ) == isFirstHit\n\n\t\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t\t|| ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\trayOrigin += rayDirection * dist - faceNormal * RAY_OFFSET;\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( transparentTraversals );\n\t\t\t\t\t\t\ttransparentTraversals -= sign( transparentTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// fetch the interpolated smooth normal\n\t\t\t\t\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t).xyz );\n\n\t\t\t\t\t\t// roughness\n\t\t\t\t\t\tfloat roughness = material.roughness;\n\t\t\t\t\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\troughness *= texture2D( textures, vec3( uv, material.roughnessMap ) ).g;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// metalness\n\t\t\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uv, material.metalnessMap ) ).b;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// emission\n\t\t\t\t\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\t\t\t\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\t\t\t\t\temission *= texture2D( textures, vec3( uv, material.emissiveMap ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// transmission\n\t\t\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uv, material.transmissionMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\ttangentAttribute,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uv, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormal *= side;\n\n\t\t\t\t\t\tSurfaceRec surfaceRec;\n\t\t\t\t\t\tsurfaceRec.normal = normal;\n\t\t\t\t\t\tsurfaceRec.faceNormal = faceNormal;\n\t\t\t\t\t\tsurfaceRec.transmission = transmission;\n\t\t\t\t\t\tsurfaceRec.ior = material.ior;\n\t\t\t\t\t\tsurfaceRec.emission = emission;\n\t\t\t\t\t\tsurfaceRec.metalness = metalness;\n\t\t\t\t\t\tsurfaceRec.color = albedo.rgb;\n\t\t\t\t\t\tsurfaceRec.roughness = roughness;\n\n\t\t\t\t\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t\t\t\t\t// then we can just always assume this is a front face.\n\t\t\t\t\t\tsurfaceRec.frontFace = side == 1.0 || transmission == 0.0;\n\n\t\t\t\t\t\t// Compute the filtered roughness value to use during specular reflection computations. A minimum\n\t\t\t\t\t\t// value of 1e-6 is needed because the GGX functions do not work with a roughness value of 0 and\n\t\t\t\t\t\t// the accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n\t\t\t\t\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t\t\t\t\t// sharp internal reflections\n\t\t\t\t\t\tsurfaceRec.filteredRoughness = clamp(\n\t\t\t\t\t\t\tmax( surfaceRec.roughness, accumulatedRoughness * filterGlossyFactor * 5.0 ),\n\t\t\t\t\t\t\t1e-3,\n\t\t\t\t\t\t\t1.0\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tmat3 normalBasis = getBasisFromNormal( surfaceRec.normal );\n\t\t\t\t\t\tmat3 invBasis = inverse( normalBasis );\n\n\t\t\t\t\t\tvec3 outgoing = - normalize( invBasis * rayDirection );\n\t\t\t\t\t\tSampleRec sampleRec = bsdfSample( outgoing, surfaceRec );\n\n\t\t\t\t\t\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t\t\t\t\t\t// maximum component-wise value of the current point to accommodate floating point\n\t\t\t\t\t\t// error as values increase.\n\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\trayDirection = normalize( normalBasis * sampleRec.direction );\n\n\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\tif ( ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( outgoing + sampleRec.direction );\n\t\t\t\t\t\t\taccumulatedRoughness += sin( acos( halfVector.z ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate color\n\t\t\t\t\t\tgl_FragColor.rgb += ( emission * throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( sampleRec.pdf <= 0.0 || ! isDirectionValid( rayDirection, normal, faceNormal) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthroughputColor *= sampleRec.color / sampleRec.pdf;\n\n\t\t\t\t\t\t// discard the sample if there are any NaNs\n\t\t\t\t\t\tif ( any( isnan( throughputColor ) ) || any( isinf( throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a = opacity;\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { MaterialStructUniform } from './MaterialStructUniform.js';\n\nexport class MaterialStructArrayUniform extends Array {\n\n\tupdateFrom( materials, textures ) {\n\n\t\twhile ( this.length > materials.length ) this.pop();\n\t\twhile ( this.length < materials.length ) this.push( new MaterialStructUniform() );\n\n\t\tfor ( let i = 0, l = this.length; i < l; i ++ ) {\n\n\t\t\tthis[ i ].updateFrom( materials[ i ], textures );\n\n\t\t}\n\n\t}\n\n}\n","import { Color, Vector2, DoubleSide, FrontSide, BackSide } from 'three';\nexport class MaterialStructUniform {\n\n\tconstructor() {\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\tthis.color = new Color( 0xffffff );\n\t\tthis.map = - 1;\n\n\t\tthis.metalness = 1.0;\n\t\tthis.metalnessMap = - 1;\n\n\t\tthis.roughness = 1.0;\n\t\tthis.roughnessMap = - 1;\n\n\t\tthis.ior = 1.0;\n\t\tthis.transmission = 0.0;\n\t\tthis.transmissionMap = - 1;\n\n\t\tthis.emissive = new Color( 0 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = - 1;\n\n\t\tthis.normalMap = - 1;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.opacity = 1.0;\n\t\tthis.alphaTest = 0.0;\n\n\t\tthis.side = 0;\n\n\t\t// TODO: Clearcoat\n\n\t\t// TODO: Sheen\n\n\t}\n\n\tupdateFrom( material, textures = [] ) {\n\n\t\tthis.init();\n\n\t\t// color\n\t\tif ( 'color' in material ) this.color.copy( material.color );\n\t\telse material.color.set( 0xffffff );\n\n\t\tthis.map = textures.indexOf( material.map );\n\n\t\t// metalness\n\t\tif ( 'metalness' in material ) this.metalness = material.metalness;\n\t\telse this.metalness = 1.0;\n\n\t\tthis.metalnessMap = textures.indexOf( material.metalnessMap );\n\n\t\t// roughness\n\t\tif ( 'roughness' in material ) this.roughness = material.roughness;\n\t\telse this.roughness = 1.0;\n\n\t\tthis.roughnessMap = textures.indexOf( material.roughnessMap );\n\n\t\t// transmission\n\t\tif ( 'ior' in material ) this.ior = material.ior;\n\t\telse this.ior = 1.0;\n\n\t\tif ( 'transmission' in material ) this.transmission = material.transmission;\n\t\telse this.transmission = 0.0;\n\n\t\tif ( 'transmissionMap' in material ) this.transmissionMap = textures.indexOf( material.transmissionMap );\n\n\t\t// emission\n\t\tif ( 'emissive' in material ) this.emissive.copy( material.emissive );\n\t\telse this.emissive.set( 0 );\n\n\t\tif ( 'emissiveIntensity' in material ) this.emissiveIntensity = material.emissiveIntensity;\n\t\telse this.emissiveIntensity = 1.0;\n\n\t\tthis.emissiveMap = textures.indexOf( material.emissiveMap );\n\n\t\t// normals\n\t\tthis.normalMap = textures.indexOf( material.normalMap );\n\t\tif ( 'normalScale' in material ) this.normalScale.copy( material.normalScale );\n\t\telse this.normalScale.set( 1, 1 );\n\n\t\t// opacity\n\t\tthis.opacity = material.opacity;\n\n\t\t// alpha test\n\t\tthis.alphaTest = material.alphaTest;\n\n\t}\n\n\tsetSide( side ) {\n\n\t\tswitch ( side ) {\n\n\t\t\tcase DoubleSide:\n\t\t\t\tthis.side = 0;\n\t\t\t\tbreak;\n\t\t\tcase FrontSide:\n\t\t\t\tthis.side = 1;\n\t\t\t\tbreak;\n\t\t\tcase BackSide:\n\t\t\t\tthis.side = - 1;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n","import {\n\tWebGLArrayRenderTarget,\n\tRGBAFormat,\n\tUnsignedByteType,\n\tMeshBasicMaterial,\n\tColor,\n\tRepeatWrapping,\n\tLinearFilter,\n\tNoToneMapping,\n} from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\n\nconst prevColor = new Color();\nexport class RenderTarget2DArray extends WebGLArrayRenderTarget {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconst tex = this.texture;\n\t\ttex.format = RGBAFormat;\n\t\ttex.type = UnsignedByteType;\n\t\ttex.minFilter = LinearFilter;\n\t\ttex.magFilter = LinearFilter;\n\t\ttex.wrapS = RepeatWrapping;\n\t\ttex.wrapT = RepeatWrapping;\n\t\ttex.setTextures = ( ...args ) => {\n\n\t\t\tthis.setTextures( ...args );\n\n\t\t};\n\n\t\tconst fsQuad = new FullScreenQuad( new MeshBasicMaterial() );\n\t\tthis.fsQuad = fsQuad;\n\n\t}\n\n\tsetTextures( renderer, width, height, textures ) {\n\n\t\t// save previous renderer state\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevToneMapping = renderer.toneMapping;\n\t\tconst prevAlpha = renderer.getClearAlpha();\n\t\trenderer.getClearColor( prevColor );\n\n\t\t// resize the render target\n\t\tconst depth = textures.length;\n\t\tthis.setSize( width, height, depth );\n\t\trenderer.setClearColor( 0, 0 );\n\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t// render each texture into each layer of the target\n\t\tconst fsQuad = this.fsQuad;\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\t\t\tfsQuad.material.map = texture;\n\t\t\tfsQuad.material.transparent = true;\n\n\t\t\trenderer.setRenderTarget( this, i );\n\t\t\tfsQuad.render( renderer );\n\n\t\t}\n\n\t\t// reset the renderer\n\t\tfsQuad.material.map = null;\n\t\trenderer.setClearColor( prevColor, prevAlpha );\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.toneMapping = prevToneMapping;\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n","import { shaderGGXFunctions } from './shaderGGXFunctions.js';\n\nexport const shaderMaterialSampling = /* glsl */`\n\nstruct SurfaceRec {\n\tvec3 normal;\n\tvec3 faceNormal;\n\tbool frontFace;\n\tfloat roughness;\n\tfloat filteredRoughness;\n\tfloat metalness;\n\tvec3 color;\n\tvec3 emission;\n\tfloat transmission;\n\tfloat ior;\n};\n\nstruct SampleRec {\n\tfloat pdf;\n\tvec3 direction;\n\tvec3 color;\n};\n\n${ shaderGGXFunctions }\n\n// diffuse\nfloat diffusePDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#lightscattering/thescatteringpdf\n\tfloat cosValue = wi.z;\n\treturn cosValue / PI;\n\n}\n\nvec3 diffuseDirection( vec3 wo, SurfaceRec surf ) {\n\n\tvec3 lightDirection = randDirection();\n\tlightDirection.z += 1.0;\n\tlightDirection = normalize( lightDirection );\n\n\treturn lightDirection;\n\n}\n\nvec3 diffuseColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// TODO: scale by 1 - F here\n\t// note on division by PI\n\t// https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n\tfloat metalFactor = ( 1.0 - surf.metalness ) * wi.z / ( PI * PI );\n\tfloat transmissionFactor = 1.0 - surf.transmission;\n\treturn surf.color * metalFactor * transmissionFactor;\n\n}\n\n// specular\nfloat specularPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// See equation (17) in http://jcgt.org/published/0003/02/03/\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = getHalfVector( wi, wo );\n\treturn ggxPDF( wi, halfVector, filteredRoughness ) / ( 4.0 * dot( wi, halfVector ) );\n\n}\n\nvec3 specularDirection( vec3 wo, SurfaceRec surf ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = ggxDirection(\n\t\two,\n\t\tfilteredRoughness,\n\t\tfilteredRoughness,\n\t\trand(),\n\t\trand()\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\treturn - reflect( wo, halfVector );\n\n}\n\nvec3 specularColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// if roughness is set to 0 then D === NaN which results in black pixels\n\tfloat metalness = surf.metalness;\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\tfloat filteredRoughness = surf.filteredRoughness;\n\n\tvec3 halfVector = getHalfVector( wo, wi );\n\tfloat iorRatio = frontFace ? 1.0 / ior : ior;\n\tfloat G = ggxShadowMaskG2( wi, wo, filteredRoughness );\n\tfloat D = ggxDistribution( halfVector, filteredRoughness );\n\n\tfloat F = schlickFresnelFromIor( dot( wi, halfVector ), iorRatio );\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tbool cannotRefract = iorRatio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = 1.0;\n\n\t}\n\n\tvec3 color = mix( vec3( 1.0 ), surf.color, metalness );\n\tcolor = mix( color, vec3( 1.0 ), F );\n\tcolor *= G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\tcolor *= mix( F, 1.0, metalness );\n\tcolor *= wi.z; // scale the light by the direction the light is coming in from\n\n\treturn color;\n\n}\n\n/*\n// transmission\nfunction transmissionPDF( wo, wi, material, surf ) {\n\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? ior : 1 / ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\thalfVector.set( 0, 0, 0 ).addScaledVector( wi, ratio ).addScaledVector( wo, 1.0 ).normalize().multiplyScalar( - 1 );\n\n\tconst denom = Math.pow( ratio * halfVector.dot( wi ) + 1.0 * halfVector.dot( wo ), 2.0 );\n\treturn ggxPDF( wo, halfVector, minRoughness ) / denom;\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\t// sample ggx vndf distribution which gives a new normal\n\tggxDirection(\n\t\two,\n\t\tminRoughness,\n\t\tminRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, halfVector, ratio, lightDirection );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wo.z )\n\t\t.multiplyScalar( transmission );\n\n}\n*/\n\n// TODO: This is just using a basic cosine-weighted specular distribution with an\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\nfloat transmissionPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 1.0 - reflectance );\n\n}\n\nvec3 transmissionDirection( vec3 wo, SurfaceRec surf ) {\n\n\tfloat roughness = surf.roughness;\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\n\tvec3 lightDirection = refract( - wo, vec3( 0.0, 0.0, 1.0 ), ratio );\n\tlightDirection += randDirection() * roughness;\n\treturn normalize( lightDirection );\n\n}\n\nvec3 transmissionColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\n\tvec3 color = surf.color;\n\tcolor *= ( 1.0 - metalness );\n\tcolor *= transmission;\n\n\treturn color;\n\n}\n\nfloat bsdfPdf( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat ior = surf.ior;\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tfloat spdf = 0.0;\n\tfloat dpdf = 0.0;\n\tfloat tpdf = 0.0;\n\n\tif ( wi.z < 0.0 ) {\n\n\t\ttpdf = transmissionPDF( wo, wi, surf );\n\n\t} else {\n\n\t\tspdf = specularPDF( wo, wi, surf );\n\t\tdpdf = diffusePDF( wo, wi, surf );\n\n\t}\n\n\tfloat transSpecularProb = mix( reflectance, 1.0, metalness );\n\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\tfloat pdf =\n\t\tspdf * transmission * transSpecularProb\n\t\t+ tpdf * transmission * ( 1.0 - transSpecularProb )\n\t\t+ spdf * ( 1.0 - transmission ) * diffSpecularProb\n\t\t+ dpdf * ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\n\treturn pdf;\n\n}\n\nvec3 bsdfColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tvec3 color = vec3( 0.0 );\n\tif ( wi.z < 0.0 ) {\n\n\t\tcolor = transmissionColor( wo, wi, surf );\n\n\t} else {\n\n\t\tcolor = diffuseColor( wo, wi, surf );\n\t\tcolor *= 1.0 - surf.transmission;\n\n\t\tcolor += specularColor( wo, wi, surf );\n\n\t}\n\n\treturn color;\n\n}\n\nSampleRec bsdfSample( vec3 wo, SurfaceRec surf ) {\n\n\tfloat ior = surf.ior;\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tSampleRec result;\n\tif ( rand() < transmission ) {\n\n\t\tfloat specularProb = mix( reflectance, 1.0, metalness );\n\t\tif ( rand() < specularProb ) {\n\n\t\t\tresult.direction = specularDirection( wo, surf );\n\n\t\t} else {\n\n\t\t\tresult.direction = transmissionDirection( wo, surf );\n\n\t\t}\n\n\t} else {\n\n\t\tfloat specularProb = 0.5 + 0.5 * metalness;\n\t\tif ( rand() < specularProb ) {\n\n\t\t\tresult.direction = specularDirection( wo, surf );\n\n\t\t} else {\n\n\t\t\tresult.direction = diffuseDirection( wo, surf );\n\n\t\t}\n\n\t}\n\n\tresult.pdf = bsdfPdf( wo, result.direction, surf );\n\tresult.color = bsdfColor( wo, result.direction, surf );\n\treturn result;\n\n}\n`;\n","export const shaderGGXFunctions = /* glsl */`\n// The GGX functions provide sampling and distribution information for normals as output so\n// in order to get probability of scatter direction the half vector must be computed and provided.\n// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n// [2] http://jcgt.org/published/0007/04/01/\n// [4] http://jcgt.org/published/0003/02/03/\n\n// trowbridge-reitz === GGX === GTR\n\nvec3 ggxDirection( vec3 incidentDir, float roughnessX, float roughnessY, float random1, float random2 ) {\n\n\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t// function below, as well\n\n\t// Implementation from reference [1]\n\t// stretch view\n\tvec3 V = normalize( vec3( roughnessX * incidentDir.x, roughnessY * incidentDir.y, incidentDir.z ) );\n\n\t// orthonormal basis\n\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\tvec3 T2 = cross( T1, V );\n\n\t// sample point with polar coordinates (r, phi)\n\tfloat a = 1.0 / ( 1.0 + V.z );\n\tfloat r = sqrt( random1 );\n\tfloat phi = ( random2 < a ) ? random2 / a * PI : PI + ( random2 - a ) / ( 1.0 - a ) * PI;\n\tfloat P1 = r * cos( phi );\n\tfloat P2 = r * sin( phi ) * ( ( random2 < a ) ? 1.0 : V.z );\n\n\t// compute normal\n\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t// unstretch\n\tN = normalize( vec3( roughnessX * N.x, roughnessY * N.y, max( 0.0, N.z ) ) );\n\n\treturn N;\n\n}\n\n// Below are PDF and related functions for use in a Monte Carlo path tracer\n// as specified in Appendix B of the following paper\n// See equation (2) from reference [2]\nfloat ggxLamda( float theta, float roughness ) {\n\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = tanTheta * tanTheta;\n\tfloat alpha2 = roughness * roughness;\n\n\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\treturn numerator / 2.0;\n\n}\n\n// See equation (2) from reference [2]\nfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n}\n\n// See equation (125) from reference [4]\nfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat scatterTheta = acos( wo.z );\n\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n}\n\nfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t// See equation (33) from reference [0]\n\tfloat a2 = roughness * roughness;\n\tfloat cosTheta = halfVector.z;\n\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\tif ( cosTheta == 0.0 ) return 0.0;\n\n\tfloat theta = acos( halfVector.z );\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\treturn a2 / denom;\n\n\t// See equation (1) from reference [2]\n\t// const { x, y, z } = halfVector;\n\t// const a2 = roughness * roughness;\n\t// const mult = x * x / a2 + y * y / a2 + z * z;\n\t// const mult2 = mult * mult;\n\n\t// return 1.0 / Math.PI * a2 * mult2;\n\n}\n\n// See equation (3) from reference [2]\nfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat D = ggxDistribution( halfVector, roughness );\n\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n}\n`;\n","import { PhysicalCamera } from '../core/PhysicalCamera.js';\nexport class PhysicalCameraUniform {\n\n\tconstructor() {\n\n\t\tthis.bokehSize = 0;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 10;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n\tupdateFrom( camera ) {\n\n\t\tif ( camera instanceof PhysicalCamera ) {\n\n\t\t\tthis.bokehSize = camera.bokehSize;\n\t\t\tthis.apertureBlades = camera.apertureBlades;\n\t\t\tthis.apertureRotation = camera.apertureRotation;\n\t\t\tthis.focusDistance = camera.focusDistance;\n\t\t\tthis.anamorphicRatio = camera.anamorphicRatio;\n\n\t\t} else {\n\n\t\t\tthis.bokehSize = 0;\n\t\t\tthis.apertureRotation = 0;\n\t\t\tthis.apertureBlades = 0;\n\t\t\tthis.focusDistance = 10;\n\t\t\tthis.anamorphicRatio = 1;\n\n\t\t}\n\n\t}\n\n}\n","import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearEncoding,\n\tLinearFilter\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* return codes for rgbe routines */\n\t\t\t//RGBE_RETURN_SUCCESS = 0,\n\t\t\tRGBE_RETURN_FAILURE = - 1,\n\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn RGBE_RETURN_FAILURE;\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tif ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {\n\n\t\t\tconst w = rgbe_header_info.width,\n\t\t\t\th = rgbe_header_info.height,\n\t\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\t\t\tif ( RGBE_RETURN_FAILURE !== image_rgba_data ) {\n\n\t\t\t\tlet data, format, type;\n\t\t\t\tlet numElements;\n\n\t\t\t\tswitch ( this.type ) {\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = floatArray;\n\t\t\t\t\t\ttype = FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = halfArray;\n\t\t\t\t\t\ttype = HalfFloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.error( 'THREE.RGBELoader: unsupported type: ', this.type );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\twidth: w, height: h,\n\t\t\t\t\tdata: data,\n\t\t\t\t\theader: rgbe_header_info.string,\n\t\t\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\t\t\texposure: rgbe_header_info.exposure,\n\t\t\t\t\tformat: format,\n\t\t\t\t\ttype: type\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n"],"names":["parcelRequire","$ilwiq","$d0f249dd9f03ac59$var$renderTask","_fsQuad","_renderer","target","camera","material","this","opacity","samples","seed","w","width","h","height","setViewOffset","Math","random","updateProjectionMatrix","tx","tiles","x","ty","y","totalTiles","dprInv","getPixelRatio","cameraWorldMatrix","copy","matrixWorld","invProjectionMatrix","projectionMatrixInverse","ogRenderTarget","getRenderTarget","ogAutoClear","autoClear","setRenderTarget","setScissorTest","setScissor","ceil","render","round","$d0f249dd9f03ac59$var$ogClearColor","Color","$d0f249dd9f03ac59$export$196da6cc71a4331","v","constructor","renderer","Vector2","WebGLRenderTarget","format","RGBAFormat","type","FloatType","stableNoise","$RPVlj","FullScreenQuad","_task","setSize","reset","ogClearAlpha","getClearAlpha","getClearColor","setClearColor","clearColor","update","call","next","$fc1143d2ee906d9d$export$b42762e2bf679e84","initialized","Boolean","bvh","scene","geometry","BufferGeometry","materials","textures","staticGeometryGenerator","$8Zfx2","StaticGeometryGenerator","dispose","generate","attributes","traverse","c","isMesh","normalMapRequired","normalMap","$jM3IF","setCommonAttributes","textureSet","Set","getMaterials","forEach","key","value","isTexture","add","materialIndexAttribute","getGroupMaterialIndicesAttribute","setAttribute","clearGroups","MeshBVH","Array","from","refit","$465cbee6efe1dae1$var$isTypedArray","arr","buffer","ArrayBuffer","$465cbee6efe1dae1$export$c80603c061964928","ignoreKeys","shareTextures","areEqual","objectA","objectB","keySet","traverseSet","a","b","Object","has","Error","aIsElement","Element","bIsElement","Image","src","aIsImageBitmap","ImageBitmap","bIsImageBitmap","equals","aIsTypedArray","bIsTypedArray","length","i","l","clear","hasOwnProperty","Function","key1","keys","values","result","delete","process","object","replaced","processMaterial","foundMaterial","otherMaterial","push","image","foundTexture","texture","isArray","retained","$911d375abf1afdea$export$baf85f88dacad6d5","PerspectiveCamera","bokehSize","size","fStop","getFocalLength","args","super","apertureBlades","apertureRotation","focusDistance","anamorphicRatio","$6b5ea45f30e12757$export$746cbc9e65f5bcb8","$9fZ6X","MaterialBase","envMap","environmentMap","parameters","transparent","depthWrite","defines","DOF_SUPPORT","TRANSPARENT_TRAVERSALS","MATERIAL_LENGTH","GRADIENT_BG","uniforms","bounces","physicalCamera","$iyhQ7","PhysicalCameraUniform","MeshBVHUniformStruct","normalAttribute","FloatVertexAttributeTexture","tangentAttribute","uvAttribute","UIntVertexAttributeTexture","$dJ2FF","MaterialStructArrayUniform","$12pjC","RenderTarget2DArray","Matrix4","environmentBlur","environmentIntensity","environmentRotation","Matrix3","filterGlossyFactor","gradientTop","gradientBottom","bgGradientTop","bgGradientBottom","vertexShader","fragmentShader","shaderStructs","shaderIntersectFunction","$5Wq6T","shaderMaterialStructs","$jNhCl","shaderUtils","$fcAdp","shaderMaterialSampling","setValues","$b5klx","$9fe18cc29d71e365$export$47e674c0d7519b0d","updateFrom","pop","MaterialStructUniform","$811ff1b00ba5f852$export$194cdc72278ea4a8","init","color","map","metalness","metalnessMap","roughness","roughnessMap","ior","transmission","transmissionMap","emissive","emissiveIntensity","emissiveMap","normalScale","alphaTest","side","set","indexOf","setSide","DoubleSide","FrontSide","BackSide","$0c199d70d276a61d$var$prevColor","$0c199d70d276a61d$export$dbbaa51cb2d0b2f7","WebGLArrayRenderTarget","args1","tex","UnsignedByteType","minFilter","LinearFilter","magFilter","wrapS","RepeatWrapping","wrapT","setTextures","fsQuad","MeshBasicMaterial","prevRenderTarget","prevToneMapping","toneMapping","prevAlpha","depth","NoToneMapping","$b114119888481524$export$aba3482f45fc2e55","shaderGGXFunctions","$8456ef8cb9b1d3a5$export$75d2a701aae03ef9","$csrdQ","$d8193d8a8d6141d1$export$2e27c77dea3c9d73","PhysicalCamera","$5ee05658f4b0e3bf$export$d076a711b55c758a","DataTextureLoader","manager","HalfFloatType","parse","buffer1","rgbe_error","rgbe_error_code","msg","console","error","fgets","lineLimit","consume","p","pos","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","byteLength","slice","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","pow","RGBEByteToRGBHalf","DataUtils","toHalfFloat","min","byteArray","Uint8Array","rgbe_header_info","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","gamma","exposure","line","match","charAt","parseFloat","parseInt","RGBE_ReadHeader","image_rgba_data","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","count","ptr","isEncodedRun","byteValue","off","RGBE_ReadPixels_RLE","data","numElements","floatArray","Float32Array","j","halfArray","j1","setDataType","load","url","onLoad","onProgress","onError","texData","encoding","LinearEncoding","generateMipmaps","flipY"],"version":3,"file":"depthOfField.0b86a860.js.map"}